<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fable Tactics – Sprites + HP/EP Bars</title>
<style>
  :root { --bg:#0e0f12; --panel:#171922; --accent:#7fe6a2; --muted:#9aa3b2; --ally:#7fe6a2; --enemy:#ff9b9b;}
  * { box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  body { margin:0; background:linear-gradient(180deg,#0b0c0f,#12131a); color:white; }
  header { padding:16px 20px; border-bottom:1px solid #222633; background:#12141c; position:sticky; top:0; z-index:5; }
  header h1 { margin:0; font-size:18px; letter-spacing:.5px; }
  main { max-width:1200px; margin:0 auto; padding:20px; display:grid; gap:16px;
    grid-template-columns: 1.1fr 0.9fr; grid-template-areas:
    "board side"
    "controls log"; }
  .panel { background:var(--panel); border:1px solid #24283a; border-radius:10px; padding:14px; box-shadow:0 6px 20px rgba(0,0,0,.25); }
  .board { grid-area:board; }
  .side { grid-area:side; display:grid; gap:16px; }
  .controls { grid-area:controls; display:flex; flex-wrap:wrap; gap:10px; align-items:flex-start; }
  .log { grid-area:log; max-height:320px; overflow:auto; background:#12141c; }
  h2 { margin:0 0 8px; font-size:14px; color:var(--muted); text-transform:uppercase; letter-spacing:.12em; }
  .small { font-size:12px; color:var(--muted); }
  .divider { height:1px; background:#222634; margin:10px 0; }

  .unit { display:flex; align-items:center; gap:10px; padding:8px; margin:6px 0; background:#11131a; border:1px solid #1f2330; border-radius:8px; }
  .unit.dead { opacity:.45; filter:grayscale(1); }
  .badge { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #2b3144; color:var(--muted); }
  .hpbar { width:100%; height:14px; background:#1b1f2b; border-radius:6px; overflow:hidden; border:1px solid #2a2f41; }
  .hp { height:100%; background:linear-gradient(90deg, #4ade80, #22c55e); }
  .row { display:flex; gap:10px; align-items:center; width:100%; }
  .col { flex:1; }
  .stats { font-size:12px; color:var(--muted); }
  .tag { font-size:11px; padding:1px 6px; border-radius:6px; background:#1b2230; border:1px solid #2a3347; margin-left:4px; }
  .turnbar { display:flex; gap:6px; flex-wrap:wrap; margin:10px 0 0; }
  .pill { font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid #2b3144; background:#111520; opacity:.9; }
  .pill.active { border-color:var(--accent); color:var(--accent); }

  button { background:#1c2636; color:white; border:1px solid #2b3144; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:600; }
  button:hover { border-color:#3a425d; }
  button.primary { background:#1e2e3d; border-color:#405a62; }
  button.ghost { background:transparent; border-color:#2b3144; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .btn-row { display:flex; gap:8px; flex-wrap:wrap; }
  .targetRow { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .targetBtn { padding:6px 10px; font-size:12px; border-radius:8px; background:#232a3b; border:1px solid #2f3750; }

  .legend { display:flex; gap:8px; flex-wrap:wrap; margin:6px 0; }
  .legend .lg { display:flex; align-items:center; gap:6px; font-size:12px; color:var(--muted); }
  .dot { width:14px; height:14px; border-radius:4px; border:1px solid #2a2f41; }

  .grid {
    --cell: 64px;
    display:grid;
    grid-template-columns: repeat(var(--w), var(--cell));
    grid-template-rows: repeat(var(--h), var(--cell));
    gap:6px;
    overflow:auto;
    max-height:70vh;
    padding:4px;
    border-radius:12px;
  }
  .cell { position:relative; border:1px solid #2a2f41; background:#101521; border-radius:8px; display:flex; align-items:center; justify-content:center; }
  .cell .coord { font-size:10px; color:#445; position:absolute; left:6px; top:4px; }
  .cell.obstacle { background:#2a1b1b; border-color:#3a2626; box-shadow: inset 0 0 0 2px rgba(120,40,40,.35); }
  .cell.obstacle::after { content:""; position:absolute; width:60%; height:60%; border-radius:6px; background:rgba(120,60,60,.35); }

  /* Terrain tints */
  .t-plain { background:#101521; }
  .t-forest { background:#112218; box-shadow: inset 0 0 0 2px rgba(60,140,80,.2); }
  .t-hill   { background:#1f1c12; box-shadow: inset 0 0 0 2px rgba(200,170,80,.25); }
  .t-road   { background:#17191f; box-shadow: inset 0 0 0 2px rgba(120,120,140,.18); }
  .t-swamp  { background:#171b15; box-shadow: inset 0 0 0 2px rgba(110,140,80,.18); }
  .t-water  { background:#0d1b27; box-shadow: inset 0 0 0 2px rgba(80,130,170,.28); }

  .cell.move-ok { outline:2px dashed var(--accent); outline-offset:-4px; }
  .cell.place { outline:2px dashed #3a7; outline-offset:-4px; cursor:pointer; }

  /* === TOKEN (sprite + double bars) === */
  .token{
    position:relative;
    width: var(--cell);
    height: var(--cell);
    border-radius:10px;
    border:1px solid #2b3144;
    background:#0f1420;
    overflow:hidden;
    box-shadow:0 6px 12px rgba(0,0,0,.25);
    display:flex; align-items:center; justify-content:center;
  }
  .token.ally { border-color:#2c4; }
  .token.enemy { border-color:#c44; }
  .token.active { box-shadow:0 0 0 2px var(--accent), 0 8px 16px rgba(0,0,0,.35); }
  .token.inrange { box-shadow: 0 0 0 2px rgba(127,230,162,.8), 0 8px 16px rgba(0,0,0,.35); }
  .token.removable { cursor:pointer; outline:2px dashed #a55; outline-offset:-4px; }
  .token .sprite{
    position:absolute; inset:0;
    background-size:cover; background-position:center;
    filter: drop-shadow(0 4px 4px rgba(0,0,0,.35));
  }
  .token .initial{
    position:absolute; bottom:22px; left:6px;
    font-weight:800; font-size:14px; color:#cfd8e3;
    text-shadow:0 1px 0 #000; opacity:.9;
  }
  .token .bars{ position:absolute; left:6px; right:6px; bottom:6px; display:flex; flex-direction:column; gap:4px; }
  .miniBar{ height:6px; border-radius:5px; border:1px solid #2a2f41; background:#121725; overflow:hidden; }
  .miniBar .hpFill{ height:100%; background:linear-gradient(90deg,#4ade80,#22c55e); width:0%; }
  .miniBar .epFill{ height:100%; background:linear-gradient(90deg,#60a5fa,#22d3ee); width:0%; }
  .token .nameplate{ position:absolute; top:6px; left:6px; right:6px; padding:2px 6px; border-radius:6px; font-size:11px; text-align:center; background:rgba(0,0,0,.45); border:1px solid #2b3144; color:#e6eefb; opacity:0; transition:.15s opacity; pointer-events:none; }
  .token:hover .nameplate{ opacity:1; }
</style>
</head>
<body>
  <header><h1>Fable Tactics • Sprites + Terrain + A*</h1></header>
  <main>
    <section class="panel board">
      <h2 id="phaseTitle">Setup: Place Units & Terrain</h2>
      <div id="board" class="grid"></div>
      <div id="boardHint" class="small" style="margin-top:8px"></div>
    </section>

    <section class="side">
      <section class="panel" id="setupPanel">
        <h2>Quick Setup</h2>
        <div class="small">Choose build/team. Toggle obstacle or terrain painting. Water is impassable. Obstacles block LOS.</div>
        <div class="divider"></div>

        <div class="btn-row" style="margin-bottom:8px">
          <label><input type="radio" name="team" value="ally" checked> Allies</label>
          <label><input type="radio" name="team" value="enemy"> Enemies</label>
        </div>

        <div class="btn-row" id="buildRow"></div>

        <div class="divider"></div>

        <!-- Grid size + zoom -->
        <div class="btn-row" style="flex-wrap:wrap; align-items:center">
          <div class="small">Grid:</div>
          <label class="small">W <input id="gridW" type="number" min="4" max="16" value="8" style="width:64px; margin-left:6px; padding:6px; background:#0f1420; border:1px solid #2a3246; border-radius:8px; color:#fff"></label>
          <label class="small">H <input id="gridH" type="number" min="3" max="12" value="6" style="width:64px; margin-left:6px; padding:6px; background:#0f1420; border:1px solid #2a3246; border-radius:8px; color:#fff"></label>
          <button id="applyGridBtn" class="ghost">Apply</button>

          <div class="small" style="margin-left:16px">Zoom:</div>
          <input id="zoomRange" type="range" min="44" max="84" value="64" step="2" style="width:160px">
          <span id="zoomVal" class="small mono">64px</span>
        </div>

        <div class="btn-row">
          <button id="obstacleBtn" class="ghost">Obstacle Mode: OFF</button>
          <button id="clearObsBtn" class="ghost">Clear Obstacles</button>
        </div>

        <div class="btn-row" style="align-items:center">
          <button id="terrainBtn" class="ghost">Terrain Mode: OFF</button>
          <select id="terrainType" style="padding:8px; background:#0f1420; color:#fff; border:1px solid #2a3246; border-radius:8px">
            <option value="plain">Plain</option>
            <option value="forest">Forest (+2 DEF, cost 2)</option>
            <option value="hill">Hill (+2 ATK, cost 2)</option>
            <option value="road">Road (cost 1)</option>
            <option value="swamp">Swamp (-2 ATK, cost 3)</option>
            <option value="water">Water (impassable)</option>
          </select>
        </div>

        <div class="legend">
          <div class="lg"><span class="dot t-forest"></span>Forest</div>
          <div class="lg"><span class="dot t-hill"></span>Hill</div>
          <div class="lg"><span class="dot t-road"></span>Road</div>
          <div class="lg"><span class="dot t-swamp"></span>Swamp</div>
          <div class="lg"><span class="dot t-water"></span>Water</div>
        </div>

        <div class="divider"></div>
        <div class="btn-row">
          <button id="presetBtn" class="ghost">Preset: Bridge Clash</button>
          <button id="fromSelectorBtn" class="ghost">Preset: From Selector</button>
          <button id="clearBtn" class="ghost">Clear Units</button>
          <button id="startBtn" class="primary">Start Battle</button>
        </div>
      </section>

      <section class="panel" id="partyPanel" style="display:none">
        <h2>Allies</h2>
        <div id="partyList"></div>
        <div class="divider"></div>
        <div>
          <div class="small">Turn Order</div>
          <div id="turnbar" class="turnbar"></div>
        </div>
      </section>

      <section class="panel" id="enemyPanel" style="display:none">
        <h2>Enemies</h2>
        <div id="enemyList"></div>
        <div class="divider"></div>
        <div class="small">Melee needs adjacency. Ranged/support need LOS. Terrain modifies ATK/DEF and path cost.</div>
      </section>
    </section>

    <section class="panel controls">
      <div class="col">
        <h2>Actions</h2>
        <div id="actionRow" class="btn-row">
          <button id="attackBtn" class="primary" disabled>Attack</button>
          <button id="abilityBtn" disabled>Ability</button>
          <button id="defendBtn" disabled>Defend</button>
          <button id="disengageBtn" disabled>Disengage</button>
          <button id="moveBtn" disabled>Move</button>
          <button id="endBtn" disabled>End Turn</button>
          <button id="autoBtn" title="Let the AI play for you" disabled>Auto-Play</button>
        </div>
        <div id="abilityRow" class="targetRow"></div>
        <div id="targetRow" class="targetRow"></div>
      </div>
    </section>

    <section class="panel log">
      <h2>Combat Log</h2>
      <div id="log"></div>
    </section>
  </main>

<script>
/* Embedded sprite URIs or URLs. Replace with your own files if you like. */
const SPRITES = {
  Knight: "https://via.placeholder.com/128x128?text=Knight",
  Fighter: "https://via.placeholder.com/128x128?text=Fighter",
  Rogue: "https://via.placeholder.com/128x128?text=Rogue",
  Archer: "https://via.placeholder.com/128x128?text=Archer",
  Bruiser: "https://via.placeholder.com/128x128?text=Bruiser",
  Imp: "https://via.placeholder.com/128x128?text=Imp",
  Cleric: "https://via.placeholder.com/128x128?text=Cleric",
  Bard: "https://via.placeholder.com/128x128?text=Bard",
  Druid: "https://via.placeholder.com/128x128?text=Druid",
  Enchanter: "https://via.placeholder.com/128x128?text=Enchanter",
  Shaman: "https://via.placeholder.com/128x128?text=Shaman",
};

/* ========= Core / Grid ========= */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const rand=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice=(arr)=>arr[Math.floor(Math.random()*arr.length)];
const GRID = { w: 8, h: 6, cell: 64, obstacles: new Set(), terrain: new Map() };
const key=(x,y)=>`${x},${y}`;
const hasObs=(x,y)=>GRID.obstacles.has(key(x,y));
const dist=(a,b)=>Math.abs(a.x-b.x)+Math.abs(a.y-b.y);
const inRange=(u,t,r)=>dist(u.pos,t.pos)<=r;
const isAdjacent=(a,b)=>dist(a,b)===1;
const TERRAIN = {
  plain:{cost:1, atk:0, def:0, pass:true},
  forest:{cost:2, atk:0, def:+2, pass:true},
  hill:{cost:2, atk:+2, def:0, pass:true},
  road:{cost:1, atk:0, def:0, pass:true},
  swamp:{cost:3, atk:-2, def:0, pass:true},
  water:{cost:999, atk:0, def:0, pass:false},
};
function tAt(x,y){ return TERRAIN[GRID.terrain.get(key(x,y))||'plain']; }
function tNameAt(x,y){ return GRID.terrain.get(key(x,y))||'plain'; }
function shortName(n){ return n.replace(/\(.*?\)/,'').trim().split(' ')[0]; }
function getUnitAt(x,y){ return G.units.find(u=>!u.dead && u.pos && u.pos.x===x && u.pos.y===y); }
function isOccupied(x,y){ return !!getUnitAt(x,y); }

/* ========= LOS ========= */
function lineCells(a,b){
  let x0=a.x, y0=a.y, x1=b.x, y1=b.y;
  const cells=[];
  const dx=Math.abs(x1-x0), dy=Math.abs(y1-y0);
  const sx = x0 < x1 ? 1 : -1;
  const sy = y0 < y1 ? 1 : -1;
  let err = dx - dy;
  while(!(x0===x1 && y0===y1)){
    const e2 = 2*err;
    if(e2> -dy){ err -= dy; x0 += sx; }
    if(e2<  dx){ err += dx; y0 += sy; }
    if(!(x0===x1 && y0===y1)) cells.push({x:x0,y:y0});
  }
  return cells;
}
function clearLine(a,b){
  for(const c of lineCells(a,b)){ if(hasObs(c.x,c.y)) return false; }
  return true;
}

/* ========= Status & Abilities ========= */
const StatusLib={
  Guard:{name:"Guard",desc:"Increase DEF by 50% for 1 turn.",duration:1,
    apply(u){u.temp.defBonus=(u.temp.defBonus||0)+Math.ceil(u.stats.def*0.5);},
    remove(u){u.temp.defBonus=0;},tick(){}},
  Bleed:{name:"Bleed",desc:"Lose 5 HP at start for 2 turns.",duration:2,
    apply(){},remove(){},tick(u,log){const dmg=5;applyDamage(u,dmg,log,`${u.name} bleeds for <span class="dmg">-${dmg}</span>.`);} },
  Root:{name:"Root",desc:"Cannot move for 1 turn.",duration:1,apply(){},remove(){},tick(){}},
  Inspire:{name:"Inspire",desc:"+2 ATK & +2 SPD for 2 turns.",duration:2,
    apply(u){u.temp.atkBuff=(u.temp.atkBuff||0)+2; u.temp.spdBuff=(u.temp.spdBuff||0)+2;},
    remove(u){u.temp.atkBuff=0; u.temp.spdBuff=0;},tick(){}},
  Shield:{name:"Shield",desc:"Absorb 15 damage for 2 turns.",duration:2,
    apply(u){u.temp.shield=(u.temp.shield||0)+15;},
    remove(u){u.temp.shield=0;},tick(){}},
};

const AbilityLib={
  Guard:{name:"Guard",desc:"Raise DEF by 50% (1 turn). Self-only.",cooldown:2,range:0,target:"self",
    use(user,_t,log){ addStatus(user,"Guard",log); log(`${user.name} braces for impact.`); } },

  PowerStrike:{name:"Power Strike",desc:"+50% ATK single hit. 1-turn CD. (range 1)",cooldown:1,range:1,target:"enemy",
    use(user,target,log){const atk=Math.ceil((effAtk(user))*1.5);const dmg=computeDamage(atk,effDef(target));applyDamage(target,dmg,log,`${user.name} uses Power Strike on ${target.name} for <span class="dmg">-${dmg}</span>.`);}},

  BleedingShot:{name:"Bleeding Shot",desc:"Light hit + Bleed. (range 3, needs LOS)",cooldown:2,range:3,target:"enemy",
    use(user,target,log){const atk=Math.ceil((effAtk(user))*0.8);const dmg=computeDamage(atk,effDef(target));applyDamage(target,dmg,log,`${user.name} uses Bleeding Shot on ${target.name} for <span class="dmg">-${dmg}</span>.`);if(!target.dead){addStatus(target,"Bleed",log);log(`${target.name} is now <span class="hit">Bleeding</span>.`);}}},

  Recover:{name:"Recover",desc:"Restore 12 HP to self.",cooldown:2,range:0,target:"self",
    use(user,_t,log){const heal=12;const before=user.hp;user.hp=clamp(user.hp+heal,0,user.stats.maxHp);log(`${user.name} recovers <span class="heal">+${user.hp-before}</span> HP.`);} },

  Heal:{name:"Heal",desc:"Restore 16 HP to an ally (R3, LOS).",cooldown:2,range:3,target:"ally",
    use(user,target,log){const heal=16;const before=target.hp;target.hp=clamp(target.hp+heal,0,target.stats.maxHp);log(`${user.name} heals ${target.name} for <span class="heal">+${target.hp-before}</span>.`);} },
  Inspire:{name:"Inspire",desc:"Buff ally with Inspire (+2 ATK & SPD, 2 turns). R3, LOS.",cooldown:3,range:3,target:"ally",
    use(user,target,log){addStatus(target,"Inspire",log);log(`${user.name} inspires ${target.name}!`);} },
  Shield:{name:"Shield",desc:"Grant a 15-HP shield to an ally (2 turns). R3, LOS.",cooldown:3,range:3,target:"ally",
    use(user,target,log){addStatus(target,"Shield",log);log(`${user.name} shields ${target.name}.`);} },
  Root:{name:"Root",desc:"Root an enemy (no movement) for 1 turn. R3, LOS.",cooldown:2,range:3,target:"enemy",
    use(user,target,log){addStatus(target,"Root",log);log(`${user.name} roots ${target.name} in place!`);} },
};

/* ========= Templates ========= */
const UnitTemplates = {
  Knight:{ label:"Knight", name:"Tallis (Knight)", stats:{maxHp:60,atk:14,def:10,spd:7}, abilities:["PowerStrike","Guard"], range:1 },
  Fighter:{ label:"Fighter", name:"Fighter", stats:{maxHp:54,atk:13,def:9, spd:9}, abilities:["PowerStrike","Guard"], range:1 },
  Rogue:{ label:"Rogue", name:"Rogue", stats:{maxHp:42,atk:12,def:6, spd:13}, abilities:["PowerStrike","Guard"], range:1 },
  Archer:{ label:"Archer", name:"Clover (Archer)", stats:{maxHp:44,atk:11,def:7, spd:12}, abilities:["BleedingShot","Recover"], range:3 },
  Bruiser:{ label:"Bruiser", name:"Goblin Bruiser", stats:{maxHp:40,atk:12,def:6, spd:8}, abilities:["PowerStrike"], range:1 },
  Imp:{ label:"Imp", name:"Woad Imp", stats:{maxHp:32,atk:9, def:5, spd:11}, abilities:["BleedingShot"], range:3 },

  Cleric:{ label:"Cleric", name:"Cleric", stats:{maxHp:46,atk:9, def:8, spd:9}, abilities:["Heal","Shield"], range:3 },
  Bard:{ label:"Bard", name:"Bard", stats:{maxHp:42,atk:9, def:7, spd:12}, abilities:["Inspire","Recover"], range:3 },
  Druid:{ label:"Druid", name:"Druid", stats:{maxHp:44,atk:10,def:7, spd:10}, abilities:["Root","Heal"], range:3 },
  Enchanter:{ label:"Enchanter", name:"Enchanter", stats:{maxHp:38,atk:10,def:6, spd:11}, abilities:["Shield","Inspire"], range:3 },
  Shaman:{ label:"Shaman", name:"Shaman", stats:{maxHp:44,atk:11,def:7, spd:10}, abilities:["Heal","Inspire"], range:3 },
};

function makeUnit(tplKey, team, pos){
  const T = UnitTemplates[tplKey] || UnitTemplates.Knight;
  return {
    id: crypto.randomUUID(),
    name: T.name, team, tplKey,
    stats: {...T.stats}, hp:T.stats.maxHp, dead:false,
    temp:{defBonus:0,defend:false,atkBuff:0,spdBuff:0,shield:0}, statuses:[],
    abilities: T.abilities.map(k=>({key:k,cd:0})),
    range: T.range,
    pos: pos? {...pos} : null,
    ep: 0, epMax: 2
  };
}

/* ========= Global State ========= */
const G={ phase:"setup", units:[], acting:null, round:1, moveMode:false, auto:false, obstacleMode:false, terrainMode:false };

/* ========= Damage / Effective Stats ========= */
function effAtk(u){ const t=u.pos? tAt(u.pos.x,u.pos.y) : TERRAIN.plain; return u.stats.atk + (u.temp.atkBuff||0) + (t.atk||0); }
function effDef(u){ const t=u.pos? tAt(u.pos.x,u.pos.y) : TERRAIN.plain; return u.stats.def + (u.temp.defBonus||0) + (u.temp.defend?2:0) + (t.def||0); }
function computeDamage(atk,def){ const base=Math.max(1, (atk) - Math.floor(def*0.7)); const variance=rand(-2,2); return Math.max(1, base+variance); }
function applyDamage(target,dmg,log,msg){
  let remaining=dmg;
  if(target.temp.shield && remaining>0){
    const used=Math.min(target.temp.shield, remaining);
    target.temp.shield -= used;
    remaining -= used;
    log(`${target.name}'s shield absorbs <span class="heal">${used}</span>.`);
  }
  if(remaining>0){
    target.hp=clamp(target.hp-remaining,0,target.stats.maxHp);
    if(msg) log(msg);
    if(target.hp===0){ target.dead=true; log(`<b>${target.name}</b> is defeated.`); }
  } else {
    if(msg) log(msg.replace(/for.+/, 'but it was fully absorbed.'));
  }
}
function addStatus(u,key,log){
  const tpl=StatusLib[key];
  if(!tpl) return;
  const ex=u.statuses.find(s=>s.key===key);
  if(ex){
    ex.turnsLeft=tpl.duration;
    if(tpl.remove) tpl.remove(u,log);
  } else {
    u.statuses.push({key,turnsLeft:tpl.duration});
  }
  if(tpl.apply) tpl.apply(u,log);
}
function tickStatusesStart(u,log){ for(const s of [...u.statuses]){ const tpl=StatusLib[s.key]; if(tpl&&tpl.tick) tpl.tick(u,log); if(u.hp===0) break; } }
function cleanupStatusesEnd(u,log){
  for(const s of [...u.statuses]){
    s.turnsLeft-=1;
    if(s.turnsLeft<=0){
      const tpl=StatusLib[s.key];
      if(tpl&&tpl.remove) tpl.remove(u,log);
      u.statuses=u.statuses.filter(x=>x!==s);
    }
  }
  u.temp.defend=false;
  u.temp.disengaged=false;
}

/* ========= Turn & Teams ========= */
function living(team){ return G.units.filter(u=>u.team===team && !u.dead); }
function anyLiving(team){ return living(team).length>0; }
function initiativeOrder(){ return G.units.filter(u=>!u.dead).slice().sort((a,b)=> (b.stats.spd + (b.temp.spdBuff||0)) - (a.stats.spd + (a.temp.spdBuff||0)) || (a.id > b.id ? 1 : -1)); }

/* ========= DOM ========= */
const BOARD=document.getElementById('board');
const PHASE=document.getElementById('phaseTitle');
const BOARD_HINT=document.getElementById('boardHint');
const SETUP_PANEL=document.getElementById('setupPanel');
const PARTY_PANEL=document.getElementById('partyPanel');
const ENEMY_PANEL=document.getElementById('enemyPanel');

const PARTY=document.getElementById('partyList');
const ENEMIES=document.getElementById('enemyList');
const TURNBAR=document.getElementById('turnbar');
const LOG=document.getElementById('log');

const ATTACK=document.getElementById('attackBtn');
const ABILITY=document.getElementById('abilityBtn');
const DEFEND=document.getElementById('defendBtn');
const DISENGAGE=document.getElementById('disengageBtn');
const MOVE=document.getElementById('moveBtn');
const END=document.getElementById('endBtn');
const AUTO=document.getElementById('autoBtn');

const TARGETS=document.getElementById('targetRow');
const ABILROW=document.getElementById('abilityRow');

const buildRow=document.getElementById('buildRow');
const presetBtn=document.getElementById('presetBtn');
const fromSelectorBtn=document.getElementById('fromSelectorBtn');
const clearBtn=document.getElementById('clearBtn');
const startBtn=document.getElementById('startBtn');

const gridWInput = document.getElementById('gridW');
const gridHInput = document.getElementById('gridH');
const applyGridBtn = document.getElementById('applyGridBtn');
const zoomRange = document.getElementById('zoomRange');
const zoomVal = document.getElementById('zoomVal');

const obstacleBtn=document.getElementById('obstacleBtn');
const clearObsBtn=document.getElementById('clearObsBtn');

const terrainBtn=document.getElementById('terrainBtn');
const terrainType=document.getElementById('terrainType');

/* ========= Build buttons ========= */
let activeBuild="Knight";
function renderBuildButtons(){
  buildRow.innerHTML="";
  Object.keys(UnitTemplates).forEach(key=>{
    const b=document.createElement('button');
    b.textContent=UnitTemplates[key].label;
    b.className = key===activeBuild ? "primary" : "";
    b.onclick=()=>{ activeBuild=key; renderBuildButtons(); renderBoard(); };
    buildRow.appendChild(b);
  });
}
function getSelectedTeam(){
  const radios=[...document.querySelectorAll('input[name="team"]')];
  const r=radios.find(x=>x.checked); return r? r.value : "ally";
}

/* ========= Grid controls ========= */
function applyGridSize(w,h){
  GRID.w = Math.max(4, Math.min(16, parseInt(w)||GRID.w));
  GRID.h = Math.max(3, Math.min(12, parseInt(h)||GRID.h));
  GRID.obstacles = new Set([...GRID.obstacles].filter(k=>{
    const [x,y]=k.split(',').map(Number);
    return x>=0 && x<GRID.w && y>=0 && y<GRID.h;
  }));
  GRID.terrain = new Map([...GRID.terrain.entries()].filter(([k,v])=>{
    const [x,y]=k.split(',').map(Number);
    return x>=0 && x<GRID.w && y>=0 && y<GRID.h;
  }));
  for(const u of G.units){
    if(!u.pos) continue;
    u.pos.x = Math.max(0, Math.min(GRID.w-1, u.pos.x));
    u.pos.y = Math.max(0, Math.min(GRID.h-1, u.pos.y));
  }
  render();
}
applyGridBtn.onclick = ()=> applyGridSize(gridWInput.value, gridHInput.value);
zoomRange.oninput = ()=>{
  GRID.cell = parseInt(zoomRange.value,10) || GRID.cell;
  zoomVal.textContent = GRID.cell + 'px';
  BOARD.style.setProperty('--cell', GRID.cell+'px');
};
obstacleBtn.onclick=()=>{
  G.obstacleMode=!G.obstacleMode;
  if(G.obstacleMode) G.terrainMode=false;
  obstacleBtn.textContent = `Obstacle Mode: ${G.obstacleMode?'ON':'OFF'}`;
  terrainBtn.textContent = `Terrain Mode: OFF`;
  render();
};
terrainBtn.onclick=()=>{
  G.terrainMode=!G.terrainMode;
  if(G.terrainMode) G.obstacleMode=false;
  terrainBtn.textContent = `Terrain Mode: ${G.terrainMode?'ON':'OFF'}`;
  obstacleBtn.textContent = `Obstacle Mode: OFF`;
  render();
};
clearObsBtn.onclick=()=>{ GRID.obstacles.clear(); render(); };

/* ========= Rendering ========= */
function log(msg){ const el=document.createElement('div'); el.className='toast'; el.innerHTML=msg; LOG.appendChild(el); LOG.scrollTop=LOG.scrollHeight; }

function render(){
  PHASE.textContent = G.phase==="setup" ? "Setup: Place Units & Terrain" : "Battle";
  BOARD.style.setProperty('--w', GRID.w);
  BOARD.style.setProperty('--h', GRID.h);
  BOARD.style.setProperty('--cell', GRID.cell + 'px');

  if(G.phase==="setup"){
    SETUP_PANEL.style.display="";
    PARTY_PANEL.style.display="none";
    ENEMY_PANEL.style.display="none";
    ATTACK.disabled=ABILITY.disabled=DEFEND.disabled=MOVE.disabled=END.disabled=true;
    AUTO.disabled=true;
    AUTO.textContent="Auto-Play";
  }else{
    SETUP_PANEL.style.display="none";
    PARTY_PANEL.style.display="";
    ENEMY_PANEL.style.display="";
    // reflect Auto state
    AUTO.disabled=false;
    AUTO.textContent = G.auto ? "Auto-Play: ON" : "Auto-Play";

    const playerTurn=G.acting && G.acting.team==='ally' && !G.acting.dead;
    const locked = G.auto; // when Auto is ON, disable manual controls
    ATTACK.disabled = !playerTurn || locked;
    ABILITY.disabled = !playerTurn || locked;
    DEFEND.disabled  = !playerTurn || locked;
    DISENGAGE.disabled = !playerTurn || locked;
    MOVE.disabled    = !playerTurn || locked;
    END.disabled     = !playerTurn || locked;
  }

  PARTY.innerHTML=''; for(const u of living('ally')) PARTY.appendChild(renderUnit(u));
  ENEMIES.innerHTML=''; for(const u of living('enemy')) ENEMIES.appendChild(renderUnit(u));

  TURNBAR.innerHTML='';
  if(G.phase==="battle"){
    for(const u of initiativeOrder()){
      const pill=document.createElement('span');
      pill.className='pill'+(G.acting&&G.acting.id===u.id?' active':'');
      pill.textContent=shortName(u.name);
      TURNBAR.appendChild(pill);
    }
  }

  renderBoard();
}

function renderUnit(u){
  const wrap=document.createElement('div');
  wrap.className='unit'+(u.dead?' dead':'');
  const side=document.createElement('div'); side.className='badge'; side.textContent=u.team==='ally'?'ALLY':'ENEMY';
  const info=document.createElement('div'); info.className='col';
  const name=document.createElement('div'); name.innerHTML=`<b>${u.name}</b>`;
  const stats=document.createElement('div'); stats.className='stats';
  const posTxt = u.pos? ` • POS (${u.pos.x},${u.pos.y}) • ${tNameAt(u.pos.x,u.pos.y).toUpperCase()}` : '';
  stats.innerHTML = `ATK ${effAtk(u)} • DEF ${effDef(u)} • SPD ${u.stats.spd + (u.temp.spdBuff||0)} • RNG ${u.range}${posTxt}`;
  const hpbar=document.createElement('div'); hpbar.className='hpbar';
  const hp=document.createElement('div'); hp.className='hp'; const pct=Math.round((u.hp/u.stats.maxHp)*100); hp.style.width=pct+'%'; hpbar.appendChild(hp);
  const statusLine=document.createElement('div'); statusLine.className='small'; statusLine.style.marginTop='6px';
  statusLine.innerHTML = `<span class="tag">EP ${u.ep}/${u.epMax}</span> ` + u.statuses.map(s=>`<span class="tag">${s.key} ${s.turnsLeft}</span>`).join(' ');
  info.appendChild(name); info.appendChild(stats); info.appendChild(hpbar); info.appendChild(statusLine);
  wrap.appendChild(side); wrap.appendChild(info);
  return wrap;
}

function renderBoard(){
  BOARD.innerHTML='';
  const placing = (G.phase==="setup");
  BOARD_HINT.innerHTML = placing
    ? (G.obstacleMode ? `Obstacle Mode: click tiles to toggle walls. Obstacles block LOS.`
       : G.terrainMode ? `Terrain Mode: painting <b>${terrainType.value.toUpperCase()}</b>. Water is impassable.`
       : `Placing: <b>${UnitTemplates[activeBuild].label}</b> for <b>${getSelectedTeam()==='ally'?'Allies':'Enemies'}</b>. Click a tile to place; click a token to remove. Toggle Obstacles/Terrain.`)
    : `Terrain applies to ATK/DEF; obstacles block LOS. AI uses A* to path around terrain and walls.`;

  const inRangeIds=new Set();
  if(G.phase==="battle" && G.acting){
    const foes = G.acting.team==='ally' ? living('enemy') : living('ally');
    for(const t of foes){
      const ok = inRange(G.acting,t,G.acting.range) && (G.acting.range===1 || clearLine(G.acting.pos,t.pos));
      if(ok) inRangeIds.add(t.id);
    }
  }

  for(let y=0;y<GRID.h;y++){
    for(let x=0;x<GRID.w;x++){
      const tClass = 't-' + (GRID.terrain.get(key(x,y))||'plain');
      const cell=document.createElement('div'); cell.className=`cell ${tClass}`+(hasObs(x,y)?' obstacle':'');
      const label=document.createElement('div'); label.className='coord'; label.textContent=`${x},${y}`; cell.appendChild(label);
      const u=getUnitAt(x,y);

      if(placing){
        if(G.obstacleMode){
          cell.onclick=()=>{ 
            if(u) return;
            if(hasObs(x,y)) GRID.obstacles.delete(key(x,y));
            else GRID.obstacles.add(key(x,y));
            render();
          };
        } else if(G.terrainMode){
          cell.onclick=()=>{
            if(hasObs(x,y)) return;
            const val = terrainType.value;
            if(val==='plain') GRID.terrain.delete(key(x,y));
            else GRID.terrain.set(key(x,y), val);
            render();
          };
        } else {
          if(!u && !hasObs(x,y) && tAt(x,y).pass){
            cell.classList.add('place');
            cell.onclick=()=>{ const team=getSelectedTeam(); G.units.push(makeUnit(activeBuild, team, {x,y})); render(); };
          }else if(u){
            const token=renderToken(u, inRangeIds);
            token.classList.add('removable');
            token.title="Remove unit";
            token.onclick=()=>{ G.units=G.units.filter(z=>z!==u); render(); };
            cell.appendChild(token);
          }
        }
      } else {
        if(u){ cell.appendChild(renderToken(u, inRangeIds)); }
        if(G.moveMode && G.acting && !u && !hasObs(x,y) && tAt(x,y).pass && isAdjacent(G.acting.pos,{x,y})){
          cell.classList.add('move-ok');
          cell.style.cursor='pointer';
          cell.onclick=()=>{ 
            if(G.acting.statuses.some(s=>s.key==='Root')){ log(`${G.acting.name} is rooted and cannot move.`); return; }
            const beforeAdj = adjacentEnemies(G.acting).filter(e=>e.ep>0);
            const prevPos = {...G.acting.pos};
            G.acting.pos={x,y};
            const afterAdj = adjacentEnemies(G.acting);
            const provoking = beforeAdj.filter(e => !afterAdj.some(a=>a.id===e.id));
            if(provoking.length && !G.acting.temp.disengaged){
              const e = provoking[0];
              e.ep = Math.max(0, e.ep-1);
              const atk = effAtk(e);
              const def = effDef(G.acting);
              const dmg = computeDamage(atk,def);
              applyDamage(G.acting, dmg, log, `${e.name} makes an <b>engagement strike</b> on ${G.acting.name} for <span class="dmg">-${dmg}</span>.`);
              if(G.acting.dead){ G.moveMode=false; render(); return endTurn(); }
            }
            log(`${G.acting.name} moves to (${x},${y}).`);
            G.moveMode=false; render(); endTurn();
          };
        }
      }

      BOARD.appendChild(cell);
    }
  }
}
function renderToken(unit, inRangeIds){
  const token=document.createElement('div');
  token.className=`token ${unit.team}`+(G.acting&&G.acting.id===unit.id?' active':'')+(inRangeIds.has(unit.id)?' inrange':'');
  const sprite=document.createElement('div');
  sprite.className='sprite';
  const url = SPRITES[unit.tplKey] || "";
  if(url) sprite.style.backgroundImage = `url("${url}")`;
  token.appendChild(sprite);

  if(!url){
    const init=document.createElement('div');
    init.className='initial';
    init.textContent = shortName(unit.name).slice(0,2).toUpperCase();
    token.appendChild(init);
  }

  const bars=document.createElement('div'); bars.className='bars';
  const hpShell=document.createElement('div'); hpShell.className='miniBar';
  const hpFill=document.createElement('div'); hpFill.className='hpFill';
  hpFill.style.width = Math.max(0, Math.round((unit.hp/unit.stats.maxHp)*100)) + '%';
  hpShell.appendChild(hpFill);

  const epShell=document.createElement('div'); epShell.className='miniBar';
  const epFill=document.createElement('div'); epFill.className='epFill';
  const epPct = Math.max(0, Math.min(100, Math.round((unit.ep / (unit.epMax||1))*100)));
  epFill.style.width = epPct + '%';
  epShell.appendChild(epFill);

  bars.appendChild(hpShell); bars.appendChild(epShell);
  token.appendChild(bars);

  const plate=document.createElement('div'); plate.className='nameplate'; plate.textContent = shortName(unit.name);
  token.appendChild(plate);

  token.title = `${unit.name}\nHP ${unit.hp}/${unit.stats.maxHp} • EP ${unit.ep}/${unit.epMax}`;
  return token;
}

/* ========= Setup controls ========= */
presetBtn.onclick=()=>{
  G.units=[];
  GRID.obstacles.clear();
  GRID.terrain.clear();
  const midX=Math.floor(GRID.w/2);
  for(let y=0;y<GRID.h;y++){ GRID.terrain.set(key(midX,y),'water'); }
  const midY=Math.floor(GRID.h/2);
  GRID.terrain.set(key(midX,midY),'road');
  GRID.terrain.set(key(midX,midY-1),'road');
  GRID.terrain.set(key(1,1),'forest');
  GRID.terrain.set(key(2,2),'forest');
  GRID.terrain.set(key(GRID.w-2,GRID.h-2),'hill');
  GRID.terrain.set(key(GRID.w-3,GRID.h-3),'hill');

  G.units.push(makeUnit("Knight","ally",{x:0,y:midY}));
  G.units.push(makeUnit("Archer","ally",{x:0,y:Math.min(GRID.h-1,midY+1)}));
  G.units.push(makeUnit("Cleric","ally",{x:0,y:Math.max(0,midY-1)}));

  G.units.push(makeUnit("Bruiser","enemy",{x:GRID.w-1,y:midY}));
  G.units.push(makeUnit("Imp","enemy",{x:GRID.w-1,y:Math.min(GRID.h-1,midY+1)}));
  G.units.push(makeUnit("Druid","enemy",{x:GRID.w-1,y:Math.max(0,midY-1)}));
  render();
};
clearBtn.onclick=()=>{ G.units=[]; render(); };

fromSelectorBtn.onclick = () => {
  try{
    const data = JSON.parse(localStorage.getItem('ft_setup') || 'null');
    if(!data || !Array.isArray(data.allies) || !Array.isArray(data.enemies)){
      alert('No selector setup found. Build one in selector.html first.');
      return;
    }
    G.units = [];
    function title(s){ return s ? s.charAt(0).toUpperCase() + s.slice(1) : s; }
    function placeList(list, team){
      for(const u of list){
        const guess = title(u.tpl);
        const pos = u.pos && typeof u.pos.x==='number' ? {x:Math.max(0,Math.min(GRID.w-1,u.pos.x)),y:Math.max(0,Math.min(GRID.h-1,u.pos.y))} : null;
        const made = makeUnit(guess in UnitTemplates ? guess : "Knight", team, pos);
        if(u.name) made.name = u.name;
        G.units.push(made);
      }
    }
    placeList(data.allies, 'ally');
    placeList(data.enemies, 'enemy');
    render();
  }catch(e){
    alert('Could not load selector setup.');
  }
};

startBtn.onclick=()=>{
  const a=living('ally').length, e=living('enemy').length;
  if(a===0 || e===0){ alert("Place at least one Ally and one Enemy."); return; }
  G.phase="battle";
  for(const u of G.units){ u.dead=false; u.hp=u.stats.maxHp; u.statuses=[]; u.temp={defBonus:0,defend:false,atkBuff:0,spdBuff:0,shield:0}; for(const a of u.abilities) a.cd=0; if(!u.pos){ autoPlace(u); } }
  log("<i>The battle begins.</i>");
  nextTurn_init();
};

function autoPlace(u){
  const leftCols = 2, rightCols = 2;
  if(u.team==='ally'){
    for(let y=0;y<GRID.h;y++){
      for(let x=0;x<Math.min(leftCols, GRID.w); x++){
        if(!getUnitAt(x,y) && !hasObs(x,y) && tAt(x,y).pass){ u.pos={x,y}; return; }
      }
    }
  } else {
    for(let y=0;y<GRID.h;y++){
      for(let x=GRID.w-1; x>=Math.max(0, GRID.w - rightCols); x--){
        if(!getUnitAt(x,y) && !hasObs(x,y) && tAt(x,y).pass){ u.pos={x,y}; return; }
      }
    }
  }
  for(let y=0;y<GRID.h;y++){
    for(let x=0;x<GRID.w;x++){
      if(!getUnitAt(x,y) && !hasObs(x,y) && tAt(x,y).pass){ u.pos={x,y}; return; }
    }
  }
}

/* ========= Battle controls ========= */
ATTACK.onclick=()=>{
  if(!(G.acting && G.acting.team==='ally')) return;
  TARGETS.innerHTML=''; ABILROW.innerHTML=''; G.moveMode=false;
  const foes=living('enemy').filter(t=>inRange(G.acting,t,G.acting.range) && (G.acting.range===1 || clearLine(G.acting.pos,t.pos)));
  if(!foes.length){ log(`No targets in range/LOS (R${G.acting.range}).`); return; }
  foes.forEach(t=>{
    const b=document.createElement('button'); b.className='targetBtn';
    b.textContent=`${shortName(t.name)} (d=${dist(G.acting.pos,t.pos)})`;
    b.onclick=()=>{
      const adj = adjacentEnemies(G.acting).filter(e=>e.ep>0);
      const isRanged = G.acting.range>1;
      if(isRanged && adj.length && !G.acting.temp.disengaged){ const e=adj[0]; e.ep=Math.max(0,e.ep-1); const atkP=effAtk(e), defP=effDef(G.acting); const dmgP=computeDamage(atkP,defP); applyDamage(G.acting,dmgP,log,`${e.name} interrupts with an <b>engagement strike</b> for <span class='dmg'>-${dmgP}</span>.`); if(G.acting.dead){ render(); return endTurn(); } }
      const atk=effAtk(G.acting);
      const def=effDef(t);
      const dmg=computeDamage(atk,def);
      applyDamage(t,dmg,log,`${G.acting.name} attacks ${t.name} for <span class="dmg">-${dmg}</span>.`);
      render(); endTurn();
    };
    TARGETS.appendChild(b);
  });
};

ABILITY.onclick=()=>{
  if(!(G.acting && G.acting.team==='ally')) return;
  TARGETS.innerHTML=''; ABILROW.innerHTML=''; G.moveMode=false;
  for(const a of G.acting.abilities){
    const tpl=AbilityLib[a.key];
    const b=document.createElement('button');
    b.className='targetBtn'; b.title=`${tpl.name}: ${tpl.desc}`;
    b.textContent=`${tpl.name}${a.cd ? ` (${a.cd})` : ''}`;
    b.disabled=a.cd>0;
    b.onclick=()=>{
      if(tpl.target==='self'){ tpl.use(G.acting, G.acting, log); a.cd=tpl.cooldown||0; render(); return endTurn(); }
      const rng=tpl.range||1;
      const isAlly = tpl.target==='ally';
      const pool = isAlly ? living('ally') : living('enemy');
      const cands=pool.filter(t=>inRange(G.acting,t,rng) && (rng===1 || clearLine(G.acting.pos,t.pos)));
      if(!cands.length){ log(`No valid targets in ${tpl.name} range/LOS (R${rng}).`); return; }
      TARGETS.innerHTML='';
      cands.forEach(t=>{
        const tb=document.createElement('button'); tb.className='targetBtn';
        tb.textContent=`${shortName(t.name)} (d=${dist(G.acting.pos,t.pos)})`;
        tb.onclick=()=>{ if((tpl.range||1)>1 && !G.acting.temp.disengaged){ const adj=adjacentEnemies(G.acting).filter(e=>e.ep>0); if(adj.length){ const e=adj[0]; e.ep=Math.max(0,e.ep-1); const atkP=effAtk(e), defP=effDef(G.acting); const dmgP=computeDamage(atkP,defP); applyDamage(G.acting,dmgP,log,`${e.name} interrupts with an <b>engagement strike</b> for <span class='dmg'>-${dmgP}</span>.`); if(G.acting.dead){ render(); return endTurn(); } } }
        tpl.use(G.acting, t, log); a.cd=tpl.cooldown||0; render(); endTurn(); };
        TARGETS.appendChild(tb);
      });
    };
    ABILROW.appendChild(b);
  }
};

DEFEND.onclick=()=>{
  if(!(G.acting && G.acting.team==='ally')) return;
  G.moveMode=false;
  G.acting.temp.defend=true;
  log(`${G.acting.name} takes a defensive stance (+2 DEF this turn).`);
  render(); endTurn();
};

DISENGAGE.onclick=()=>{
  if(!(G.acting && G.acting.team==='ally')) return;
  G.acting.temp.disengaged=true;
  log(`${G.acting.name} prepares to <b>disengage</b> (no engagement strikes this turn).`);
  render(); endTurn();
};

MOVE.onclick=()=>{
  if(!(G.acting && G.acting.team==='ally')) return;
  if(G.acting.statuses.some(s=>s.key==='Root')){ log(`${G.acting.name} is rooted and cannot move.`); return; }
  G.moveMode=!G.moveMode;
  if(G.moveMode) log(`Select an adjacent, empty, passable tile for ${G.acting.name} to move.`);
  render();
};

END.onclick=()=>{
  if(!(G.acting && G.acting.team==='ally')) return;
  G.moveMode=false; log(`${G.acting.name} ends their turn.`); endTurn();
};

AUTO.onclick=()=>{
  G.auto=!G.auto;
  render(); // reflect new label/disabled states
  if(G.auto && G.acting && G.acting.team==='ally'){
    aiAct(); // kick it off immediately if it's our turn
  }
};

/* ========= Turn flow ========= */
function nextTurn_init(){
  const order=initiativeOrder();
  G.acting=order[0]||null;
  render(); if(G.acting) startTurn();
}
function nextTurn_advance(){
  if(!anyLiving('ally')||!anyLiving('enemy')) return endBattle();
  const order=initiativeOrder();
  const idx=order.findIndex(u=>u.id===G.acting.id);
  G.acting=order[(idx+1)%order.length];
  if((idx+1)%order.length===0) G.round++;
  render(); startTurn();
}
function startTurn(){
  if(G.acting.dead) { return nextTurn_advance(); }
  log(`<span class="small">— Round ${G.round} • ${G.acting.name}'s turn —</span>`);
  tickStatusesStart(G.acting, log);
  if(G.acting.dead){ render(); return nextTurn_advance(); }
  for(const a of G.acting.abilities) a.cd=Math.max(0,a.cd-1);
  if(G.acting.pos){ const adj = adjacentEnemies(G.acting); if(adj.length>0) { G.acting.ep = Math.min(G.acting.epMax, G.acting.ep+1); log(`${G.acting.name} gains <b>+1 EP</b> from engagement (${G.acting.ep}/${G.acting.epMax}).`);} }
  render();
  if(G.acting.team==='enemy' || G.auto) aiAct();
}
function endTurn(){ cleanupStatusesEnd(G.acting, log); render(); nextTurn_advance(); }

function endBattle(){
  const win=anyLiving('ally') && !anyLiving('enemy');
  const lose=!anyLiving('ally') && anyLiving('enemy');
  log(win? "<b>Victory!</b> All enemies defeated."
      : lose? "<b>Defeat.</b> The party has fallen."
      : "<b>Battle Ends.</b>");
  ATTACK.disabled = ABILITY.disabled = DEFEND.disabled = MOVE.disabled = END.disabled = true;
  G.auto=false; render();
}

/* ========= Helpers ========= */
function adjacentEnemies(u){
  const foes = living(u.team==='ally'?'enemy':'ally');
  return foes.filter(t=>isAdjacent(u.pos, t.pos));
}

/* ========= A* (occupancy-aware) ========= */
function neighbors(p, goal){
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  const out=[];
  for(const [dx,dy] of dirs){
    const x=p.x+dx, y=p.y+dy;
    if(x<0||x>=GRID.w||y<0||y>=GRID.h) continue;
    if(hasObs(x,y)) continue;
    const terr=tAt(x,y);
    if(!terr.pass) continue;
    if(!(goal && x===goal.x && y===goal.y) && isOccupied(x,y)) continue;
    out.push({x,y, cost: terr.cost});
  }
  return out;
}
function aStar(start,goal){
  const gScore=new Map(), fScore=new Map(), came=new Map();
  const open=new Set([key(start.x,start.y)]);
  gScore.set(key(start.x,start.y),0);
  fScore.set(key(start.x,start.y), dist(start,goal));

  function lowest(){
    let bestK=null, best=Infinity;
    for(const k of open){
      const f=fScore.get(k) ?? Infinity;
      if(f<best){ best=f; bestK=k; }
    }
    return bestK;
  }
  while(open.size){
    const curK=lowest();
    const [cx,cy]=curK.split(',').map(Number);
    if(cx===goal.x && cy===goal.y){
      const path=[]; let k=curK;
      while(k){ const [x,y]=k.split(',').map(Number); path.push({x,y}); k=came.get(k); }
      path.reverse();
      return path;
    }
    open.delete(curK);
    for(const nb of neighbors({x:cx,y:cy}, goal)){
      const nk=key(nb.x,nb.y);
      const tentative = (gScore.get(curK) ?? Infinity) + nb.cost;
      if(tentative < (gScore.get(nk) ?? Infinity)){
        came.set(nk, curK);
        gScore.set(nk, tentative);
        const h = dist({x:nb.x,y:nb.y}, goal);
        fScore.set(nk, tentative + h);
        if(!open.has(nk)) open.add(nk);
      }
    }
  }
  return null;
}

/* ========= AI ========= */
function aiAct(){
  const u=G.acting; if(!u || u.dead) return;
  setTimeout(()=>{
    const foes=living(u.team==='ally'?'enemy':'ally');
    const ready=u.abilities.filter(a=>a.cd===0).map(a=>({a,tpl:AbilityLib[a.key]}));

    // Support if useful
    const allyPool=living(u.team);
    const lowAlly = allyPool.slice().sort((a,b)=>(a.hp/a.stats.maxHp)-(b.hp/b.stats.maxHp))[0];
    const canHeal = ready.find(x=>x.tpl===AbilityLib.Heal) && lowAlly && inRange(u,lowAlly,3) && clearLine(u.pos,lowAlly.pos) && lowAlly.hp<=lowAlly.stats.maxHp-10;
    if(canHeal){ AbilityLib.Heal.use(u, lowAlly, log); ready.find(x=>x.tpl===AbilityLib.Heal).a.cd=AbilityLib.Heal.cooldown; render(); return endTurn(); }
    const canShield = ready.find(x=>x.tpl===AbilityLib.Shield) && lowAlly && inRange(u,lowAlly,3) && clearLine(u.pos,lowAlly.pos) && (lowAlly.temp.shield||0)<8;
    if(canShield){ AbilityLib.Shield.use(u, lowAlly, log); ready.find(x=>x.tpl===AbilityLib.Shield).a.cd=AbilityLib.Shield.cooldown; render(); return endTurn(); }

    // Offensive ability
    const damaging=ready.filter(x=>x.tpl.target==='enemy');
    const usable=damaging.find(x=>foes.some(t=>inRange(u,t,x.tpl.range||1) && (x.tpl.range===1 || clearLine(u.pos,t.pos))));
    if(usable){
      const rng=usable.tpl.range||1;
      const cands=foes.filter(t=>inRange(u,t,rng) && (rng===1 || clearLine(u.pos,t.pos)));
      const t=choice(cands);
      usable.tpl.use(u,t,log); usable.a.cd=usable.tpl.cooldown||0; render(); return endTurn();
    }

    // Basic attack
    const attackables=foes.filter(t=>inRange(u,t,u.range) && (u.range===1 || clearLine(u.pos,t.pos)));
    if(attackables.length){
      const t=attackables.slice().sort((a,b)=> (effDef(a)) - (effDef(b)) )[0];
      const atk=effAtk(u), def=effDef(t);
      const dmg=computeDamage(atk,def);
      applyDamage(t,dmg,log,`${u.name} attacks ${t.name} for <span class="dmg">-${dmg}</span>.`);
      render(); return endTurn();
    }

    // Disengage if threatened by EP and low HP
    const adjThreats = adjacentEnemies(u).filter(e=>e.ep>0);
    if(adjThreats.length && u.hp <= Math.ceil(u.stats.maxHp*0.35)){
      u.temp.disengaged=true;
      log(`${u.name} disengages to avoid punishment.`);
      render(); return endTurn();
    }

    // Move via A*
    const target=foes.slice().sort((a,b)=>dist(u.pos,a.pos)-dist(u.pos,b.pos))[0];
    if(target){
      const path = aStar(u.pos, target.pos);
      if(path && path.length>=2){
        const step = path[1];
        if(!getUnitAt(step.x,step.y)){ 
          u.pos=step; 
          log(`${u.name} advances via terrain to (${step.x},${step.y}).`); 
          render(); return endTurn(); 
        }
      }
      // fallback greedy
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){
        const nx=u.pos.x+dx, ny=u.pos.y+dy;
        if(nx<0||ny<0||nx>=GRID.w||ny>=GRID.h) continue;
        if(!getUnitAt(nx,ny) && !hasObs(nx,ny) && tAt(nx,ny).pass){ u.pos={x:nx,y:ny}; log(`${u.name} inches forward.`); render(); return endTurn(); }
      }
    }
    u.temp.defend=true; log(`${u.name} defends.`); render(); endTurn();
  }, 250);
}

/* ========= Boot ========= */
(function preloadSprites(){ Object.values(SPRITES).forEach(src=>{ if(!src) return; const i=new Image(); i.src=src; }); })();
(function boot(){
  renderBuildButtons();
  render();
  BOARD.style.setProperty('--cell', GRID.cell + 'px');
  gridWInput.value = GRID.w;
  gridHInput.value = GRID.h;
  zoomRange.value = GRID.cell;
  zoomVal.textContent = GRID.cell + 'px';
})();
</script>
</body>
</html>
