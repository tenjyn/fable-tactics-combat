<script>
/* ---------------------------
   Minimal Battle Engine + Grid + Ranges
---------------------------- */
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = (arr)=>arr[Math.floor(Math.random()*arr.length)];

const GRID_W = 6, GRID_H = 4;

// Manhattan distance + helpers
const dist = (a,b)=> Math.abs(a.x-b.x) + Math.abs(a.y-b.y);
const inRange = (user, target, r)=> dist(user.pos, target.pos) <= r;

const StatusLib = {
  Guard: { name:"Guard", desc:"Increase DEF by 50% for 1 turn.", apply(u){ u.temp.defBonus=(u.temp.defBonus||0)+Math.ceil(u.stats.def*0.5); }, remove(u){ u.temp.defBonus=0; }, duration:1, tick(){} },
  Bleed: { name:"Bleed", desc:"Lose 5 HP at start for 2 turns.", apply(){}, remove(){}, duration:2, tick(u,log){ const dmg=5; u.hp=clamp(u.hp-dmg,0,u.stats.maxHp); log(`${u.name} bleeds for <span class="dmg">-${dmg}</span>.`); } }
};

// Ability ranges: self=0, melee=1, ranger-ish=3
const AbilityLib = {
  PowerStrike: { name:"Power Strike", desc:"+50% ATK single hit. 1-turn CD. (range 1)", cooldown:1, range:1, user:"enemy|ally", target:"enemy",
    use(user,target,log){ const atk=Math.ceil(user.stats.atk*1.5); const dmg=computeDamage(atk, target.stats.def + (target.temp.defBonus||0)); dealDamage(target,dmg,`${user.name} uses Power Strike on ${target.name} for <span class="dmg">-${dmg}</span>.`,log); } },
  Guard: { name:"Guard", desc:"Gain Guard for 1 turn.", cooldown:2, range:0, user:"self", target:"self",
    use(user,_t,log){ addStatus(user,"Guard",log); log(`${user.name} braces and gains <span class="hit">Guard</span>.`); } },
  BleedingShot: { name:"Bleeding Shot", desc:"Light hit + Bleed. (range 3)", cooldown:2, range:3, user:"enemy|ally", target:"enemy",
    use(user,target,log){ const atk=Math.ceil(user.stats.atk*0.8); const dmg=computeDamage(atk, target.stats.def + (target.temp.defBonus||0)); dealDamage(target,dmg,`${user.name} uses Bleeding Shot on ${target.name} for <span class="dmg">-${dmg}</span>.`,log); if(!target.dead){ addStatus(target,"Bleed",log); log(`${target.name} is now <span class="hit">Bleeding</span>.`);} } },
  Recover: { name:"Recover", desc:"Restore 12 HP to self.", cooldown:2, range:0, user:"self", target:"self",
    use(user,_t,log){ const heal=12; const before=user.hp; user.hp=clamp(user.hp+heal,0,user.stats.maxHp); log(`${user.name} recovers <span class="heal">+${user.hp-before}</span> HP.`);} }
};

function makeUnit(name, team, stats, abilityKeys, pos, attackRange){
  return {
    id: crypto.randomUUID(), name, team,
    stats: {...stats}, hp: stats.maxHp, dead:false,
    temp:{ defBonus:0, defend:false }, statuses:[],
    abilities: abilityKeys.map(k=>({ key:k, cd:0 })),
    pos: {...pos},          // {x,y}
    range: attackRange||1   // basic attack range
  };
}

// Party: Knight melee(1), Ranger ranged(3)
const party = [
  makeUnit("Tallis (Knight)", "ally",  {maxHp:60, atk:14, def:10, spd:7},  ["PowerStrike","Guard"],       {x:0,y:1}, 1),
  makeUnit("Clover (Ranger)", "ally",  {maxHp:44, atk:11, def:7,  spd:12}, ["BleedingShot","Recover"],    {x:0,y:2}, 3),
];
const enemies = [
  makeUnit("Goblin Bruiser", "enemy",  {maxHp:40, atk:12, def:6, spd:8},   ["PowerStrike"],               {x:5,y:1}, 1),
  makeUnit("Woad Imp",       "enemy",  {maxHp:32, atk:9,  def:5, spd:11},  ["BleedingShot"],              {x:5,y:2}, 3),
];

const G = { units:[...party, ...enemies], turnIndex:0, round:1, acting:null, auto:false, moveMode:false };

function computeDamage(atk, def){ const base=Math.max(1, atk - Math.floor(def*0.7)); const variance=rand(-2,2); return Math.max(1, base+variance); }
function dealDamage(target,dmg,msg,log){ target.hp=clamp(target.hp-dmg,0,target.stats.maxHp); if(msg) log(msg); if(target.hp===0){ target.dead=true; log(`<b>${target.name}</b> is defeated.`);} }
function addStatus(u,key,log){ const tpl=StatusLib[key]; if(!tpl) return; const ex=u.statuses.find(s=>s.key===key); if(ex) ex.turnsLeft=tpl.duration; else u.statuses.push({key,turnsLeft:tpl.duration}); tpl.apply(u,log); }
function tickStatusesStart(u,log){ for(const s of [...u.statuses]){ const tpl=StatusLib[s.key]; if(tpl&&tpl.tick) tpl.tick(u,log); if(u.hp===0) break; } }
function cleanupStatusesEnd(u,log){ for(const s of [...u.statuses]){ s.turnsLeft-=1; if(s.turnsLeft<=0){ const tpl=StatusLib[s.key]; if(tpl&&tpl.remove) tpl.remove(u,log); u.statuses=u.statuses.filter(x=>x!==s);} } u.temp.defend=false; u.temp.defBonus=0; }
function living(team){ return G.units.filter(u=>u.team===team && !u.dead); }
function anyLiving(team){ return living(team).length>0; }
function getUnitAt(x,y){ return G.units.find(u=>!u.dead && u.pos.x===x && u.pos.y===y); }

function initiativeOrder(){
  return G.units.filter(u=>!u.dead).slice().sort((a,b)=> b.stats.spd - a.stats.spd || (a.id > b.id ? 1 : -1));
}

function log(msg){ const el=document.createElement('div'); el.className='toast'; el.innerHTML=msg; LOG.appendChild(el); LOG.scrollTop=LOG.scrollHeight; }

function render(){
  // Lists
  PARTY.innerHTML=''; for(const u of party) PARTY.appendChild(renderUnit(u));
  ENEMIES.innerHTML=''; for(const u of enemies) ENEMIES.appendChild(renderUnit(u));
  // Turnbar
  TURNBAR.innerHTML=''; for(const u of initiativeOrder()){ const pill=document.createElement('span'); pill.className='pill'+(G.acting&&G.acting.id===u.id?' active':''); pill.textContent=u.name.split(' ')[0]; TURNBAR.appendChild(pill); }
  // Controls
  const playerTurn=G.acting && G.acting.team==='ally' && !G.acting.dead;
  ATTACK.disabled = !playerTurn;
  ABILITY.disabled = !playerTurn;
  DEFEND.disabled = !playerTurn;
  MOVE.disabled = !playerTurn;
  END.disabled = !playerTurn;
  // Board
  renderBoard();
}

function renderUnit(u){
  const wrap=document.createElement('div');
  wrap.className='unit'+(u.dead?' dead':'');
  const side=document.createElement('div'); side.className='badge'; side.textContent=u.team==='ally'?'ALLY':'ENEMY';
  const info=document.createElement('div'); info.className='col';
  const name=document.createElement('div'); name.innerHTML=`<b>${u.name}</b>`;
  const stats=document.createElement('div'); stats.className='stats';
  const defNow=u.stats.def + (u.temp.defBonus||0) + (u.temp.defend?2:0);
  stats.innerHTML = `ATK ${u.stats.atk} • DEF ${defNow} • SPD ${u.stats.spd} • POS (${u.pos.x},${u.pos.y}) • RNG ${u.range}`;
  const hpbar=document.createElement('div'); hpbar.className='hpbar';
  const hp=document.createElement('div'); hp.className='hp'; const pct=Math.round((u.hp/u.stats.maxHp)*100); hp.style.width=pct+'%'; hpbar.appendChild(hp);
  const statusLine=document.createElement('div'); statusLine.className='small'; statusLine.style.marginTop='6px';
  statusLine.innerHTML = u.statuses.map(s=>`<span class="tag">${s.key} ${s.turnsLeft}</span>`).join(' ');
  info.appendChild(name); info.appendChild(stats); info.appendChild(hpbar); info.appendChild(statusLine);
  wrap.appendChild(side); wrap.appendChild(info);
  return wrap;
}

/* ---------- Board UI ---------- */
function renderBoard(){
  BOARD.style.setProperty('--w', GRID_W);
  BOARD.style.setProperty('--h', GRID_H);
  BOARD.innerHTML='';

  // Precompute "in-range" targets for the acting unit (basic attack lens)
  const inRangeIds = new Set();
  if(G.acting){
    const foes = G.acting.team==='ally' ? living('enemy') : living('ally');
    for(const t of foes){ if(inRange(G.acting, t, G.acting.range)) inRangeIds.add(t.id); }
  }

  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      const cell=document.createElement('div'); cell.className='cell'; cell.dataset.x=x; cell.dataset.y=y;
      const label=document.createElement('div'); label.className='cell coord'; label.textContent=`${x},${y}`; cell.appendChild(label);
      const unit=getUnitAt(x,y);
      if(unit){
        const token=document.createElement('div'); token.className=`token ${unit.team}`+(G.acting&&G.acting.id===unit.id?' active':'')+(inRangeIds.has(unit.id)?' inrange':'');
        const name=document.createElement('div'); name.className='name'; name.textContent=shortName(unit.name);
        const hpmini=document.createElement('div'); hpmini.className='hpmini';
        const span=document.createElement('span'); span.style.width = Math.round((unit.hp/unit.stats.maxHp)*100)+'%';
        hpmini.appendChild(span);
        token.appendChild(name); token.appendChild(hpmini);
        cell.appendChild(token);
      }
      // Move highlights
      if(G.moveMode && G.acting && !unit && isAdjacent(G.acting.pos, {x,y})){
        cell.classList.add('move-ok');
        cell.style.cursor='pointer';
        cell.onclick=()=>{ G.acting.pos={x,y}; log(`${G.acting.name} moves to (${x},${y}).`); G.moveMode=false; render(); endTurn(); };
      }
      BOARD.appendChild(cell);
    }
  }
}
function shortName(n){ return n.replace(/\(.*?\)/,'').trim().split(' ')[0]; }
function isAdjacent(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)===1; }

/* ---------- Turn Loop ---------- */
function nextTurn(){
  if(!anyLiving('ally')||!anyLiving('enemy')) return endBattle();
  const order=initiativeOrder();
  if(!G.acting) G.acting=order[0];
  else{
    const idx=order.findIndex(u=>u.id===G.acting.id);
    G.acting=order[(idx+1)%order.length];
    if((idx+1)%order.length===0) G.round++;
  }
  render();
  if(G.acting.dead) return nextTurn();
  log(`<span class="small">— Round ${G.round} • ${G.acting.name}'s turn —</span>`);
  tickStatusesStart(G.acting, log);
  if(G.acting.dead){ render(); return nextTurn(); }
  for(const a of G.acting.abilities) a.cd=Math.max(0,a.cd-1);
  render();
  if(G.acting.team==='enemy' || G.auto) aiAct();
}

function endTurn(){
  cleanupStatusesEnd(G.acting, log);
  render();
  nextTurn();
}

function endBattle(){
  const win=anyLiving('ally') && !anyLiving('enemy');
  const lose=!anyLiving('ally') && anyLiving('enemy');
  const text= win ? "<b>Victory!</b> All enemies defeated."
             : lose ? "<b>Defeat.</b> The party has fallen."
             : "<b>Battle Ends.</b>";
  log(text);
  ATTACK.disabled = ABILITY.disabled = DEFEND.disabled = MOVE.disabled = END.disabled = true;
  AUTO.textContent="Auto-Play"; G.auto=false;
}

/* ---------- Targeting ---------- */
function validTargets(user, scope){
  if(scope==='self') return [user];
  if(scope==='enemy') return user.team==='ally' ? living('enemy') : living('ally');
  return [];
}

/* ---------- Controls ---------- */
const PARTY   = document.getElementById('partyList');
const ENEMIES = document.getElementById('enemyList');
const TURNBAR = document.getElementById('turnbar');
const LOG     = document.getElementById('log');
const BOARD   = document.getElementById('board');

const ATTACK  = document.getElementById('attackBtn');
const ABILITY = document.getElementById('abilityBtn');
const DEFEND  = document.getElementById('defendBtn');
const MOVE    = document.getElementById('moveBtn');
const END     = document.getElementById('endBtn');
const AUTO    = document.getElementById('autoBtn');

const TARGETS = document.getElementById('targetRow');
const ABILROW = document.getElementById('abilityRow');

ATTACK.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false; TARGETS.innerHTML=''; ABILROW.innerHTML='';
  const foes=validTargets(G.acting,'enemy').filter(t => inRange(G.acting, t, G.acting.range));
  if(!foes.length){ log(`No targets in range (R${G.acting.range}). Try <b>Move</b>.`); return; }
  foes.forEach(t=>{
    const b=document.createElement('button');
    b.className='targetBtn';
    b.textContent=`${shortName(t.name)} (d=${dist(G.acting.pos,t.pos)})`;
    b.onclick=()=>{
      const atk=G.acting.stats.atk;
      const def=t.stats.def+(t.temp.defBonus||0)+(t.temp.defend?2:0);
      const dmg=computeDamage(atk,def);
      dealDamage(t,dmg,`${G.acting.name} attacks ${t.name} for <span class="dmg">-${dmg}</span>.`,log);
      render(); endTurn();
    };
    TARGETS.appendChild(b);
  });
});

ABILITY.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false; TARGETS.innerHTML=''; ABILROW.innerHTML='';
  for(const a of G.acting.abilities){
    const tpl=AbilityLib[a.key];
    const b=document.createElement('button');
    b.className='targetBtn'; b.title=`${tpl.name}: ${tpl.desc}`;
    b.textContent=`${tpl.name}${a.cd ? ` (${a.cd})` : ''}`;
    b.disabled=a.cd>0;
    b.onclick=()=>{
      const scope=tpl.target; 
      if(scope==='self'){ tpl.use(G.acting, G.acting, log); a.cd=tpl.cooldown||0; render(); return endTurn(); }
      // enemy-targeted: filter by ability range
      const candidates = validTargets(G.acting,'enemy').filter(t => inRange(G.acting, t, tpl.range||1));
      if(!candidates.length){ log(`No valid targets in ability range (R${tpl.range||1}). Try <b>Move</b>.`); return; }
      TARGETS.innerHTML='';
      candidates.forEach(t=>{
        const tb=document.createElement('button'); tb.className='targetBtn';
        tb.textContent=`${shortName(t.name)} (d=${dist(G.acting.pos,t.pos)})`;
        tb.onclick=()=>{ tpl.use(G.acting, t, log); a.cd=tpl.cooldown||0; render(); endTurn(); };
        TARGETS.appendChild(tb);
      });
    };
    ABILROW.appendChild(b);
  }
});

DEFEND.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false;
  G.acting.temp.defend=true;
  log(`${G.acting.name} takes a defensive stance (+2 DEF this turn).`);
  render(); endTurn();
});

MOVE.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode = !G.moveMode;
  if(G.moveMode) log(`Select an adjacent tile for ${G.acting.name} to move.`);
  render();
});

END.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false;
  log(`${G.acting.name} ends their turn.`);
  endTurn();
});

AUTO.addEventListener('click', () => {
  G.auto=!G.auto;
  AUTO.textContent=G.auto?"Auto-Play: ON":"Auto-Play";
  if(G.auto && G.acting && G.acting.team==='ally') aiAct();
});

/* ---------- AI (respects range) ---------- */
function aiAct(){
  const u=G.acting; if(!u || u.dead) return;
  setTimeout(()=>{
    const foes=validTargets(u,'enemy');
    // If have a damaging ability in range, prefer it
    const ready=u.abilities.filter(a=>a.cd===0).map(a=>({a,tpl:AbilityLib[a.key]}));
    const recover=ready.find(x=>x.tpl===AbilityLib.Recover);
    const damaging=ready.filter(x=>x.tpl.target==='enemy' && x.tpl.use);
    const inRangeAbility = damaging.find(x => foes.some(t => inRange(u,t,x.tpl.range||1)));

    if(recover && u.hp<=Math.ceil(u.stats.maxHp*0.5) && Math.random()<0.4){
      recover.tpl.use(u,u,log); recover.a.cd=recover.tpl.cooldown||0; render(); return endTurn();
    }

    if(inRangeAbility){
      const rng = inRangeAbility.tpl.range||1;
      const cands = foes.filter(t=>inRange(u,t,rng));
      const t = choice(cands);
      inRangeAbility.tpl.use(u,t,log);
      inRangeAbility.a.cd=inRangeAbility.tpl.cooldown||0;
      render(); return endTurn();
    }

    // If basic attack is in range, do it
    const attackables = foes.filter(t=>inRange(u,t,u.range));
    if(attackables.length){
      const t = attackables.slice().sort((a,b)=>(a.hp/a.stats.maxHp)-(b.hp/b.stats.maxHp))[0];
      const atk=u.stats.atk, def=t.stats.def+(t.temp.defBonus||0)+(t.temp.defend?2:0);
      const dmg=computeDamage(atk,def); dealDamage(t,dmg,`${u.name} attacks ${t.name} for <span class="dmg">-${dmg}</span>.`,log);
      render(); return endTurn();
    }

    // Otherwise, step toward nearest foe
    const nearest = foes.slice().sort((a,b)=> dist(u.pos,a.pos)-dist(u.pos,b.pos))[0];
    if(nearest){
      const step = stepToward(u.pos, nearest.pos);
      if(step && !getUnitAt(step.x, step.y)){ u.pos=step; log(`${u.name} advances to (${step.x},${step.y}).`); render(); return endTurn(); }
    }

    // If stuck, defend
    u.temp.defend=true; log(`${u.name} defends.`);
    render(); endTurn();
  }, 450);
}

// tiny greedy step toward a target (orthogonal only)
function stepToward(a,b){
  const dx = b.x - a.x, dy = b.y - a.y;
  const cand = [];
  if(Math.abs(dx)>=Math.abs(dy)) {
    if(dx!==0) cand.push({x:a.x + Math.sign(dx), y:a.y});
    if(dy!==0) cand.push({x:a.x, y:a.y + Math.sign(dy)});
  } else {
    if(dy!==0) cand.push({x:a.x, y:a.y + Math.sign(dy)});
    if(dx!==0) cand.push({x:a.x + Math.sign(dx), y:a.y});
  }
  for(const p of cand){
    if(p.x>=0 && p.x<GRID_W && p.y>=0 && p.y<GRID_H) return p;
  }
  return null;
}

/* ---------- Boot ---------- */
(function boot(){
  render(); log("<i>The battle begins.</i>"); nextTurn();
})();
</script>
