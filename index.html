<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fable Tactics – Grid Turn-Based Combat</title>
<style>
  :root { --bg:#0e0f12; --panel:#171922; --accent:#7fe6a2; --muted:#9aa3b2; --bad:#ff7a7a; --good:#8bd5ff; --ally:#7fe6a2; --enemy:#ff9b9b;}
  * { box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  body { margin:0; background:linear-gradient(180deg,#0b0c0f,#12131a); color:white; }
  header { padding:16px 20px; border-bottom:1px solid #222633; background:#12141c; position:sticky; top:0; z-index:5; }
  header h1 { margin:0; font-size:18px; letter-spacing:.5px; }
  main { max-width:1200px; margin:0 auto; padding:20px; display:grid; gap:16px;
    grid-template-columns: 1.1fr 0.9fr; grid-template-areas:
    "board side"
    "controls log"; }
  .panel { background:var(--panel); border:1px solid #24283a; border-radius:10px; padding:14px; box-shadow:0 6px 20px rgba(0,0,0,.25); }
  .board { grid-area:board; }
  .side { grid-area:side; display:grid; gap:16px; }
  .party, .enemies { }
  .controls { grid-area:controls; display:flex; flex-wrap:wrap; gap:10px; align-items:flex-start; }
  .log { grid-area:log; max-height:320px; overflow:auto; background:#12141c; }
  h2 { margin:0 0 8px; font-size:14px; color:var(--muted); text-transform:uppercase; letter-spacing:.12em; }

  /* List styling */
  .unit { display:flex; align-items:center; gap:10px; padding:8px; margin:6px 0; background:#11131a; border:1px solid #1f2330; border-radius:8px; }
  .unit.dead { opacity:.45; filter:grayscale(1); }
  .badge { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #2b3144; color:var(--muted); }
  .hpbar { width:100%; height:14px; background:#1b1f2b; border-radius:6px; overflow:hidden; border:1px solid #2a2f41; }
  .hp { height:100%; background:linear-gradient(90deg, #4ade80, #22c55e); }
  .row { display:flex; gap:10px; align-items:center; width:100%; }
  .col { flex:1; }
  .stats { font-size:12px; color:var(--muted); }
  .tag { font-size:11px; padding:1px 6px; border-radius:6px; background:#1b2230; border:1px solid #2a3347; margin-left:4px; }
  .turnbar { display:flex; gap:6px; flex-wrap:wrap; margin:10px 0 0; }
  .pill { font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid #2b3144; background:#111520; opacity:.9; }
  .pill.active { border-color:var(--accent); color:var(--accent); }

  /* Controls & log */
  button { background:#1c2636; color:white; border:1px solid #2b3144; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:600; }
  button:hover { border-color:#3a425d; }
  button.primary { background:#1e2e3d; border-color:#405a62; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .targetRow { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .targetBtn { padding:6px 10px; font-size:12px; border-radius:8px; background:#232a3b; border:1px solid #2f3750; }
  .toast { padding:8px 12px; border-bottom:1px solid #20263a; font-size:14px; line-height:1.35; }
  .hit { color:#ffd08a; }
  .heal { color:#8bf0a6; }
  .dmg { color:#ff9b9b; }
  .small { font-size:12px; color:var(--muted); }
  .divider { height:1px; background:#222634; margin:10px 0; }

  /* Board grid */
  .grid { display:grid; grid-template-columns: repeat(var(--w), 1fr); grid-template-rows: repeat(var(--h), 64px); gap:6px; }
  .cell { position:relative; border:1px solid #2a2f41; background:#0f1420; border-radius:8px; display:flex; align-items:center; justify-content:center; }
  .cell.coord { font-size:10px; color:#445; position:absolute; left:6px; top:4px; }
  .cell.move-ok { outline:2px dashed var(--accent); outline-offset:-4px; }
  .token { display:flex; flex-direction:column; align-items:center; gap:2px; padding:6px 8px; border-radius:10px; border:1px solid #2b3144; background:#121a26; box-shadow:0 6px 12px rgba(0,0,0,.25); }
  .token.ally { border-color:#2c4; }
  .token.enemy { border-color:#c44; }
  .token .name { font-size:12px; font-weight:700; }
  .token .hpmini { width:56px; height:6px; border-radius:4px; background:#1b1f2b; border:1px solid #2a2f41; overflow:hidden; }
  .token .hpmini > span { display:block; height:100%; background:linear-gradient(90deg,#4ade80,#22c55e); }
  .token.active { box-shadow:0 0 0 2px var(--accent), 0 8px 16px rgba(0,0,0,.35); }
</style>
</head>
<body>
  <header><h1>Fable Tactics • Grid Turn-Based Combat</h1></header>
  <main>
    <section class="panel board">
      <h2>Board</h2>
      <div id="board" class="grid"></div>
      <div class="small" style="margin-top:8px">Click <b>Move</b> to relocate the acting unit one tile (orthogonal). Tokens glow when it’s their turn.</div>
    </section>

    <section class="side">
      <section class="panel party">
        <h2>Party</h2>
        <div id="partyList"></div>
        <div class="divider"></div>
        <div>
          <div class="small">Turn Order</div>
          <div id="turnbar" class="turnbar"></div>
        </div>
      </section>

      <section class="panel enemies">
        <h2>Enemies</h2>
        <div id="enemyList"></div>
        <div class="divider"></div>
        <div class="small">Tip: Abilities can apply status (Guard, Bleed). Defend = temporary armor.</div>
      </section>
    </section>

    <section class="panel controls">
      <div class="col">
        <h2>Actions</h2>
        <div id="actionRow">
          <button id="attackBtn" class="primary">Attack</button>
          <button id="abilityBtn">Ability</button>
          <button id="defendBtn">Defend</button>
          <button id="moveBtn">Move</button>
          <button id="endBtn">End Turn</button>
          <button id="autoBtn" title="Let the AI play for you">Auto-Play</button>
        </div>
        <div id="abilityRow" class="targetRow"></div>
        <div id="targetRow" class="targetRow"></div>
      </div>
    </section>

    <section class="panel log">
      <h2>Combat Log</h2>
      <div id="log"></div>
    </section>
  </main>

<script>
/* ---------------------------
   Minimal Battle Engine + Grid
---------------------------- */
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const choice = (arr)=>arr[Math.floor(Math.random()*arr.length)];

const GRID_W = 6, GRID_H = 4;
const StatusLib = {
  Guard: { name:"Guard", desc:"Increase DEF by 50% for 1 turn.", apply(u){ u.temp.defBonus=(u.temp.defBonus||0)+Math.ceil(u.stats.def*0.5); }, remove(u){ u.temp.defBonus=0; }, duration:1, tick(){} },
  Bleed: { name:"Bleed", desc:"Lose 5 HP at start for 2 turns.", apply(){}, remove(){}, duration:2, tick(u,log){ const dmg=5; u.hp=clamp(u.hp-dmg,0,u.stats.maxHp); log(`${u.name} bleeds for <span class="dmg">-${dmg}</span>.`); } }
};
const AbilityLib = {
  PowerStrike: { name:"Power Strike", desc:"+50% ATK single hit. 1-turn CD.", cooldown:1, user:"enemy|ally", target:"enemy",
    use(user,target,log){ const atk=Math.ceil(user.stats.atk*1.5); const dmg=computeDamage(atk, target.stats.def + (target.temp.defBonus||0)); dealDamage(target,dmg,`${user.name} uses Power Strike on ${target.name} for <span class="dmg">-${dmg}</span>.`,log); } },
  Guard: { name:"Guard", desc:"Gain Guard for 1 turn.", cooldown:2, user:"self", target:"self",
    use(user,_t,log){ addStatus(user,"Guard",log); log(`${user.name} braces and gains <span class="hit">Guard</span>.`); } },
  BleedingShot: { name:"Bleeding Shot", desc:"Light hit + Bleed.", cooldown:2, user:"enemy|ally", target:"enemy",
    use(user,target,log){ const atk=Math.ceil(user.stats.atk*0.8); const dmg=computeDamage(atk, target.stats.def + (target.temp.defBonus||0)); dealDamage(target,dmg,`${user.name} uses Bleeding Shot on ${target.name} for <span class="dmg">-${dmg}</span>.`,log); if(!target.dead){ addStatus(target,"Bleed",log); log(`${target.name} is now <span class="hit">Bleeding</span>.`);} } },
  Recover: { name:"Recover", desc:"Restore 12 HP to self.", cooldown:2, user:"self", target:"self",
    use(user,_t,log){ const heal=12; const before=user.hp; user.hp=clamp(user.hp+heal,0,user.stats.maxHp); log(`${user.name} recovers <span class="heal">+${user.hp-before}</span> HP.`);} }
};

function makeUnit(name, team, stats, abilityKeys, pos){
  return {
    id: crypto.randomUUID(), name, team,
    stats: {...stats}, hp: stats.maxHp, dead:false,
    temp:{ defBonus:0, defend:false }, statuses:[],
    abilities: abilityKeys.map(k=>({ key:k, cd:0 })),
    pos: {...pos} // {x,y}
  };
}

const party = [
  makeUnit("Tallis (Knight)", "ally",  {maxHp:60, atk:14, def:10, spd:7},  ["PowerStrike","Guard"],       {x:0,y:1}),
  makeUnit("Clover (Ranger)", "ally",  {maxHp:44, atk:11, def:7,  spd:12}, ["BleedingShot","Recover"],    {x:0,y:2}),
];
const enemies = [
  makeUnit("Goblin Bruiser", "enemy",  {maxHp:40, atk:12, def:6, spd:8},   ["PowerStrike"],               {x:5,y:1}),
  makeUnit("Woad Imp",       "enemy",  {maxHp:32, atk:9,  def:5, spd:11},  ["BleedingShot"],              {x:5,y:2}),
];

const G = { units:[...party, ...enemies], turnIndex:0, round:1, acting:null, auto:false, moveMode:false };

function computeDamage(atk, def){ const base=Math.max(1, atk - Math.floor(def*0.7)); const variance=rand(-2,2); return Math.max(1, base+variance); }
function dealDamage(target,dmg,msg,log){ target.hp=clamp(target.hp-dmg,0,target.stats.maxHp); if(msg) log(msg); if(target.hp===0){ target.dead=true; log(`<b>${target.name}</b> is defeated.`);} }
function addStatus(u,key,log){ const tpl=StatusLib[key]; if(!tpl) return; const ex=u.statuses.find(s=>s.key===key); if(ex) ex.turnsLeft=tpl.duration; else u.statuses.push({key,turnsLeft:tpl.duration}); tpl.apply(u,log); }
function tickStatusesStart(u,log){ for(const s of [...u.statuses]){ const tpl=StatusLib[s.key]; if(tpl&&tpl.tick) tpl.tick(u,log); if(u.hp===0) break; } }
function cleanupStatusesEnd(u,log){ for(const s of [...u.statuses]){ s.turnsLeft-=1; if(s.turnsLeft<=0){ const tpl=StatusLib[s.key]; if(tpl&&tpl.remove) tpl.remove(u,log); u.statuses=u.statuses.filter(x=>x!==s);} } u.temp.defend=false; u.temp.defBonus=0; }
function living(team){ return G.units.filter(u=>u.team===team && !u.dead); }
function anyLiving(team){ return living(team).length>0; }
function getUnitAt(x,y){ return G.units.find(u=>!u.dead && u.pos.x===x && u.pos.y===y); }

function initiativeOrder(){
  return G.units.filter(u=>!u.dead).slice().sort((a,b)=> b.stats.spd - a.stats.spd || (a.id > b.id ? 1 : -1));
}

function log(msg){ const el=document.createElement('div'); el.className='toast'; el.innerHTML=msg; LOG.appendChild(el); LOG.scrollTop=LOG.scrollHeight; }

function render(){
  // Lists
  PARTY.innerHTML=''; for(const u of party) PARTY.appendChild(renderUnit(u));
  ENEMIES.innerHTML=''; for(const u of enemies) ENEMIES.appendChild(renderUnit(u));
  // Turnbar
  TURNBAR.innerHTML=''; for(const u of initiativeOrder()){ const pill=document.createElement('span'); pill.className='pill'+(G.acting&&G.acting.id===u.id?' active':''); pill.textContent=u.name.split(' ')[0]; TURNBAR.appendChild(pill); }
  // Controls
  const playerTurn=G.acting && G.acting.team==='ally' && !G.acting.dead;
  ATTACK.disabled = !playerTurn;
  ABILITY.disabled = !playerTurn;
  DEFEND.disabled = !playerTurn;
  MOVE.disabled = !playerTurn;
  END.disabled = !playerTurn;
  // Board
  renderBoard();
}

function renderUnit(u){
  const wrap=document.createElement('div');
  wrap.className='unit'+(u.dead?' dead':'');
  const side=document.createElement('div'); side.className='badge'; side.textContent=u.team==='ally'?'ALLY':'ENEMY';
  const info=document.createElement('div'); info.className='col';
  const name=document.createElement('div'); name.innerHTML=`<b>${u.name}</b>`;
  const stats=document.createElement('div'); stats.className='stats';
  const defNow=u.stats.def + (u.temp.defBonus||0) + (u.temp.defend?2:0);
  stats.innerHTML = `ATK ${u.stats.atk} • DEF ${defNow} • SPD ${u.stats.spd} • POS (${u.pos.x},${u.pos.y})`;
  const hpbar=document.createElement('div'); hpbar.className='hpbar';
  const hp=document.createElement('div'); hp.className='hp'; const pct=Math.round((u.hp/u.stats.maxHp)*100); hp.style.width=pct+'%'; hpbar.appendChild(hp);
  const statusLine=document.createElement('div'); statusLine.className='small'; statusLine.style.marginTop='6px';
  statusLine.innerHTML = u.statuses.map(s=>`<span class="tag">${s.key} ${s.turnsLeft}</span>`).join(' ');
  info.appendChild(name); info.appendChild(stats); info.appendChild(hpbar); info.appendChild(statusLine);
  wrap.appendChild(side); wrap.appendChild(info);
  return wrap;
}

/* ---------- Board UI ---------- */
function renderBoard(){
  BOARD.style.setProperty('--w', GRID_W);
  BOARD.style.setProperty('--h', GRID_H);
  BOARD.innerHTML='';
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      const cell=document.createElement('div'); cell.className='cell'; cell.dataset.x=x; cell.dataset.y=y;
      const label=document.createElement('div'); label.className='cell coord'; label.textContent=`${x},${y}`; cell.appendChild(label);
      const unit=getUnitAt(x,y);
      if(unit){
        const token=document.createElement('div'); token.className=`token ${unit.team}`+(G.acting&&G.acting.id===unit.id?' active':'');
        const name=document.createElement('div'); name.className='name'; name.textContent=shortName(unit.name);
        const hpmini=document.createElement('div'); hpmini.className='hpmini';
        const span=document.createElement('span'); span.style.width = Math.round((unit.hp/unit.stats.maxHp)*100)+'%';
        hpmini.appendChild(span);
        token.appendChild(name); token.appendChild(hpmini);
        cell.appendChild(token);
      }
      // Move highlights
      if(G.moveMode && G.acting && !unit && isAdjacent(G.acting.pos, {x,y})){
        cell.classList.add('move-ok');
        cell.style.cursor='pointer';
        cell.onclick=()=>{ G.acting.pos={x,y}; log(`${G.acting.name} moves to (${x},${y}).`); G.moveMode=false; render(); /* moving consumes the action; end turn */ endTurn(); };
      }
      BOARD.appendChild(cell);
    }
  }
}
function shortName(n){ return n.replace(/\(.*?\)/,'').trim().split(' ')[0]; }
function isAdjacent(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)===1; }

/* ---------- Turn Loop ---------- */
function nextTurn(){
  if(!anyLiving('ally')||!anyLiving('enemy')) return endBattle();
  const order=initiativeOrder();
  if(!G.acting) G.acting=order[0];
  else{
    const idx=order.findIndex(u=>u.id===G.acting.id);
    G.acting=order[(idx+1)%order.length];
    if((idx+1)%order.length===0) G.round++;
  }
  render();
  if(G.acting.dead) return nextTurn();
  log(`<span class="small">— Round ${G.round} • ${G.acting.name}'s turn —</span>`);
  tickStatusesStart(G.acting, log);
  if(G.acting.dead){ render(); return nextTurn(); }
  for(const a of G.acting.abilities) a.cd=Math.max(0,a.cd-1);
  render();
  if(G.acting.team==='enemy' || G.auto) aiAct();
}

function endTurn(){
  cleanupStatusesEnd(G.acting, log);
  render();
  nextTurn();
}

function endBattle(){
  const win=anyLiving('ally') && !anyLiving('enemy');
  const lose=!anyLiving('ally') && anyLiving('enemy');
  const text= win ? "<b>Victory!</b> All enemies defeated."
             : lose ? "<b>Defeat.</b> The party has fallen."
             : "<b>Battle Ends.</b>";
  log(text);
  ATTACK.disabled = ABILITY.disabled = DEFEND.disabled = MOVE.disabled = END.disabled = true;
  AUTO.textContent="Auto-Play"; G.auto=false;
}

/* ---------- Targeting & Validity ---------- */
function validTargets(user, scope){
  if(scope==='self') return [user];
  if(scope==='enemy') return user.team==='ally' ? living('enemy') : living('ally');
  return [];
}

/* ---------- Controls ---------- */
const PARTY   = document.getElementById('partyList');
const ENEMIES = document.getElementById('enemyList');
const TURNBAR = document.getElementById('turnbar');
const LOG     = document.getElementById('log');
const BOARD   = document.getElementById('board');

const ATTACK  = document.getElementById('attackBtn');
const ABILITY = document.getElementById('abilityBtn');
const DEFEND  = document.getElementById('defendBtn');
const MOVE    = document.getElementById('moveBtn');
const END     = document.getElementById('endBtn');
const AUTO    = document.getElementById('autoBtn');

const TARGETS = document.getElementById('targetRow');
const ABILROW = document.getElementById('abilityRow');

ATTACK.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false; TARGETS.innerHTML=''; ABILROW.innerHTML='';
  const foes=validTargets(G.acting,'enemy');
  foes.forEach(t=>{
    const b=document.createElement('button');
    b.className='targetBtn';
    b.textContent=shortName(t.name);
    b.onclick=()=>{
      const atk=G.acting.stats.atk;
      const def=t.stats.def+(t.temp.defBonus||0)+(t.temp.defend?2:0);
      const dmg=computeDamage(atk,def);
      dealDamage(t,dmg,`${G.acting.name} attacks ${t.name} for <span class="dmg">-${dmg}</span>.`,log);
      render(); endTurn();
    };
    TARGETS.appendChild(b);
  });
});

ABILITY.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false; TARGETS.innerHTML=''; ABILROW.innerHTML='';
  for(const a of G.acting.abilities){
    const tpl=AbilityLib[a.key];
    const b=document.createElement('button');
    b.className='targetBtn'; b.title=`${tpl.name}: ${tpl.desc}`;
    b.textContent=`${tpl.name}${a.cd ? ` (${a.cd})` : ''}`;
    b.disabled=a.cd>0;
    b.onclick=()=>{
      const scope=tpl.target; const candidates=validTargets(G.acting, scope);
      if(scope==='self' || candidates.length===1){
        const target=candidates[0]; tpl.use(G.acting, target, log); a.cd=tpl.cooldown||0; render(); endTurn();
      } else {
        TARGETS.innerHTML='';
        candidates.forEach(t=>{
          const tb=document.createElement('button'); tb.className='targetBtn'; tb.textContent=shortName(t.name);
          tb.onclick=()=>{ tpl.use(G.acting, t, log); a.cd=tpl.cooldown||0; render(); endTurn(); };
          TARGETS.appendChild(tb);
        });
      }
    };
    ABILROW.appendChild(b);
  }
});

DEFEND.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false;
  G.acting.temp.defend=true;
  log(`${G.acting.name} takes a defensive stance (+2 DEF this turn).`);
  render(); endTurn();
});

MOVE.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  // Toggle move mode: lets the player click one orthogonally adjacent empty cell.
  G.moveMode = !G.moveMode;
  if(G.moveMode) log(`Select an adjacent tile for ${G.acting.name} to move.`);
  render();
});

END.addEventListener('click', () => {
  if(!G.acting || G.acting.team!=='ally') return;
  G.moveMode=false;
  log(`${G.acting.name} ends their turn.`);
  endTurn();
});

AUTO.addEventListener('click', () => {
  G.auto=!G.auto;
  AUTO.textContent=G.auto?"Auto-Play: ON":"Auto-Play";
  if(G.auto && G.acting && G.acting.team==='ally') aiAct();
});

/* ---------- AI ---------- */
function aiAct(){
  const u=G.acting; if(!u || u.dead) return;
  setTimeout(()=>{
    // 20% chance to try a small step toward closest foe (if path open and adjacent)
    const foes=validTargets(u,'enemy');
    if(foes.length && Math.random()<0.2){
      const t=foes[0]; const step = stepToward(u.pos, t.pos);
      if(step && !getUnitAt(step.x, step.y)){ u.pos=step; log(`${u.name} shuffles to (${step.x},${step.y}).`); render(); return endTurn(); }
    }
    const ready=u.abilities.filter(a=>a.cd===0).map(a=>({a,tpl:AbilityLib[a.key]}));
    const recover=ready.find(x=>x.tpl===AbilityLib.Recover);
    const damaging=ready.filter(x=>x.tpl.target==='enemy' && x.tpl.use);

    if(recover && u.hp<=Math.ceil(u.stats.maxHp*0.5) && Math.random()<0.4){
      recover.tpl.use(u,u,log); recover.a.cd=recover.tpl.cooldown||0; render(); return endTurn();
    }
    if(damaging.length && Math.random()<0.7){
      const pick=choice(damaging); const candidates=validTargets(u,'enemy'); if(candidates.length){
        const t=choice(candidates); pick.tpl.use(u,t,log); pick.a.cd=pick.tpl.cooldown||0; render(); return endTurn();
      }
    }
    // Attack weakest
    const targets=validTargets(u,'enemy');
    if(targets.length){
      const t=targets.slice().sort((a,b)=>(a.hp/a.stats.maxHp)-(b.hp/b.stats.maxHp))[0];
      const atk=u.stats.atk, def=t.stats.def+(t.temp.defBonus||0)+(t.temp.defend?2:0);
      const dmg=computeDamage(atk,def); dealDamage(t,dmg,`${u.name} attacks ${t.name} for <span class="dmg">-${dmg}</span>.`,log);
    }
    render(); endTurn();
  }, 450);
}

// tiny greedy step toward a target (orthogonal only)
function stepToward(a,b){
  const dx = b.x - a.x, dy = b.y - a.y;
  const cand = [];
  if(dx!==0) cand.push({x:a.x + Math.sign(dx), y:a.y});
  if(dy!==0) cand.push({x:a.x, y:a.y + Math.sign(dy)});
  // prefer x move, then y, but keep within bounds
  for(const p of cand){
    if(p.x>=0 && p.x<GRID_W && p.y>=0 && p.y<GRID_H) return p;
  }
  return null;
}

/* ---------- Boot ---------- */
(function boot(){
  render(); log("<i>The battle begins.</i>"); nextTurn();
})();
</script>
</body>
</html>
